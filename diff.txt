diff --git a/.env b/.env
index 00290fe..3307212 100644
--- a/.env
+++ b/.env
@@ -1,12 +1,9 @@
-# === Wallet & Blockchain Config ===
-WALLET_MNEMONIC="diamond like interest affair safe clarify lawsuit innocent beef van grief color"
-NETUID=18
-HOTKEY="5FFApaS75bv5pJHfAp2FVLBj9ZaXuFDjEypsaBNc1wCfe52v"
-
-# === Environment Mode ===
-IS_DOCKER=false
-
-# === External APIs ===
-DATURA_API_KEY=dt_$your_datura_key_here
-CHUTES_API_KEY=cpk_$your_chutes_key_here
-DATABASE_URL=postgresql+asyncpg://user:password@localhost:5432/yourdb
+API_TOKEN=datura
+JWT_SECRET=some_secure_random_string
+JWT_ALGORITHM=HS256
+JWT_EXPIRATION_MINUTES=30
+DATURA_API_KEY=dt$q4qWC2K5mwT5BnNh0ZNF9MfeMDJenJ-pddsi_rE1FZ8
+CHUTES_API_KEY=cpk_9402c24cc755440b94f4b0931ebaa272.7a748b60e4a557f6957af9ce25778f49.8huXjHVlrSttzKuuY0yU2Fy4qEskr5J0
+POSTGRES_USER=postgres
+POSTGRES_PASSWORD=postgres
+POSTGRES_DB=bittensor
\ No newline at end of file
diff --git a/.env.example b/.env.example
index 00290fe..9c06da2 100644
--- a/.env.example
+++ b/.env.example
@@ -1,12 +1,20 @@
 # === Wallet & Blockchain Config ===
-WALLET_MNEMONIC="diamond like interest affair safe clarify lawsuit innocent beef van grief color"
+WALLET_MNEMONIC="your_mnemonic_here"
 NETUID=18
-HOTKEY="5FFApaS75bv5pJHfAp2FVLBj9ZaXuFDjEypsaBNc1wCfe52v"
+HOTKEY="your_hotkey_here"
 
 # === Environment Mode ===
 IS_DOCKER=false
 
+# === Authentication ===
+API_TOKEN=your_api_token_here
+JWT_SECRET=your_jwt_secret_here
+JWT_ALGORITHM=HS256
+JWT_EXPIRATION_MINUTES=30
+
 # === External APIs ===
-DATURA_API_KEY=dt_$your_datura_key_here
-CHUTES_API_KEY=cpk_$your_chutes_key_here
-DATABASE_URL=postgresql+asyncpg://user:password@localhost:5432/yourdb
+DATURA_API_KEY=dt_your_datura_key_here
+CHUTES_API_KEY=cpk_your_chutes_key_here
+
+# === Database ===
+DATABASE_URL=postgresql+asyncpg://user:password@localhost:5432/yourdb
\ No newline at end of file
diff --git a/bittensor_async_app/__pycache__/main.cpython-313.pyc b/bittensor_async_app/__pycache__/main.cpython-313.pyc
index 26af68f..3e127f0 100644
Binary files a/bittensor_async_app/__pycache__/main.cpython-313.pyc and b/bittensor_async_app/__pycache__/main.cpython-313.pyc differ
diff --git a/bittensor_async_app/main.py b/bittensor_async_app/main.py
index 32887de..4e09da6 100644
--- a/bittensor_async_app/main.py
+++ b/bittensor_async_app/main.py
@@ -5,6 +5,7 @@ from typing import Optional, Dict, Any, List
 import time, os
 import logging
 import traceback
+import asyncio
 
 # Configure logging
 logging.basicConfig(level=logging.INFO)
@@ -53,11 +54,10 @@ def verify_token(credentials: HTTPAuthorizationCredentials = Depends(security)):
     token = credentials.credentials
     if token not in VALID_TOKENS:
         raise HTTPException(
-            status_code=status.HTTP_403_FORBIDDEN,
+            status_code=status.HTTP_403_FORBIDDEN,  # Change from 401 to 403
             detail="Invalid or missing token"
         )
     return token
-
 # Optional JWT token endpoint - only available if auth module is present
 if auth_available:
     @app.post("/token", response_model=Token)
@@ -177,6 +177,11 @@ async def health_check():
     client = bittensor_client.get_client()
     is_initialized = getattr(client, "is_initialized", False)
     
+    # Attempt to initialize if not already initialized
+    if not is_initialized:
+        # Try to initialize but don't wait for completion
+        asyncio.create_task(client.initialize())
+    
     status_info = {
         "status": "healthy" if is_initialized else "degraded",
         "bittensor_client": "initialized" if is_initialized else "not_initialized",
@@ -205,10 +210,11 @@ async def startup_event():
     
     # Initialize Bittensor client
     try:
-        await bittensor_client.initialize()
-        logger.info("Bittensor client initialized successfully")
+        # Don't await here - let it run in the background so startup isn't blocked
+        asyncio.create_task(bittensor_client.initialize())
+        logger.info("Bittensor client initialization task started")
     except Exception as e:
-        logger.error(f"Failed to initialize Bittensor client: {e}")
+        logger.error(f"Failed to start Bittensor client initialization: {e}")
         logger.error(traceback.format_exc())
         # Application will still start, but in degraded mode
 
diff --git a/bittensor_async_app/services/__pycache__/bittensor_client.cpython-313.pyc b/bittensor_async_app/services/__pycache__/bittensor_client.cpython-313.pyc
index 5939a7b..f8db688 100644
Binary files a/bittensor_async_app/services/__pycache__/bittensor_client.cpython-313.pyc and b/bittensor_async_app/services/__pycache__/bittensor_client.cpython-313.pyc differ
diff --git a/bittensor_async_app/services/bittensor_client.py b/bittensor_async_app/services/bittensor_client.py
index 39d4418..f841eca 100644
--- a/bittensor_async_app/services/bittensor_client.py
+++ b/bittensor_async_app/services/bittensor_client.py
@@ -4,10 +4,10 @@ import logging
 import random
 from typing import Dict, Any, Optional, Union
 import asyncio
+import time
 from datetime import datetime
 
 import bittensor
-from bittensor.core.async_subtensor import AsyncSubtensor
 
 # Configure logging
 logger = logging.getLogger(__name__)
@@ -53,6 +53,9 @@ class BitensorClient:
         self.subtensor = None
         self.wallet = None
         self.is_initialized = False
+        self.initialization_error = None
+        self.last_init_attempt = 0
+        self.init_retry_interval = 60  # seconds between retry attempts
         
         # Default values from environment
         self.default_netuid = int(os.getenv("NETUID", 18))
@@ -71,93 +74,102 @@ class BitensorClient:
             # Initialize subtensor connection asynchronously
             asyncio.create_task(self.initialize())
     
-    async def initialize(self) -> None:
+    async def initialize(self) -> bool:
         """
         Initialize the connection to the Bittensor blockchain.
         
-        This method sets up the AsyncSubtensor instance and wallet.
+        This method sets up the subtensor instance and wallet.
         It's called automatically when the client is created.
+        
+        Returns:
+            bool: True if initialization was successful, False otherwise
         """
         # Skip if already initialized or in test environment
         if self.is_initialized or "PYTEST_CURRENT_TEST" in os.environ:
             return True
+        
+        # Prevent too frequent retry attempts
+        current_time = time.time()
+        if current_time - self.last_init_attempt < self.init_retry_interval:
+            return False
             
-        try:
-            logger.info("Initializing Bittensor client...")
-            
-            # Create wallet with the mnemonic from environment
-            wallet_mnemonic = os.getenv("WALLET_MNEMONIC", "")
-            
-            if self.is_docker:
-                # For Docker, we'll just use an in-memory wallet
-                # This avoids file permission issues in containerized environments
-                logger.info("Running in Docker, using in-memory wallet")
-                self.wallet = bittensor.wallet(
-                    name="default",
-                    hotkey="default",
-                    mnemonic=wallet_mnemonic,
-                    password="",
-                    path="/tmp/bittensor/wallets",
-                    crypto_type=1  # sr25519 format
-                )
-            else:
-                # For non-Docker environments, use the normal wallet path
-                logger.info("Using filesystem wallet")
-                self.wallet = bittensor.wallet(
-                    name=os.getenv("WALLET_NAME", "default"),
-                    hotkey=os.getenv("WALLET_HOTKEY", "default"),
-                    mnemonic=wallet_mnemonic if wallet_mnemonic else None,
-                    password="",  # Empty password for automation
-                    crypto_type=1  # sr25519 format
-                )
-            
-            # Connect to the testnet
-            self.subtensor = AsyncSubtensor(
-                network="test",
-                chain_endpoint=os.getenv("BLOCKCHAIN_ENDPOINT", "wss://test.finney.opentensor.ai:443"),
-                wallet=self.wallet
-            )
-            
-            # Set global variables for test compatibility
-            global subtensor, async_subtensor, is_initialized
-            subtensor = self.subtensor
-            async_subtensor = self.subtensor
-            is_initialized = True
-            
-            logger.info(f"Bittensor client initialized successfully")
-            self.is_initialized = True
-            return True
-            
-        except bittensor.errors.KeyFileError as e:
-            logger.error(f"Error creating wallet: {str(e)}")
-            raise RuntimeError(f"Failed to create wallet: {str(e)}")
-        except Exception as e:
-            logger.error(f"Error initializing Bittensor client: {str(e)}")
-            raise RuntimeError(f"Failed to initialize Bittensor client: {str(e)}")
+        self.last_init_attempt = current_time
+        
+        # Try multiple times with increasing delays
+        for attempt in range(1, 4):
+            try:
+                logger.info(f"Initializing Bittensor client (attempt {attempt}/3)...")
+                
+                # Create wallet with the mnemonic from environment
+                wallet_mnemonic = os.getenv("WALLET_MNEMONIC", "")
+                
+                if self.is_docker:
+                    # For Docker, we'll just use an in-memory wallet
+                    # This avoids file permission issues in containerized environments
+                    logger.info("Running in Docker, using in-memory wallet")
+                    self.wallet = bittensor.wallet(
+                        name="default",
+                        hotkey="default"
+                    )
+                else:
+                    # For non-Docker environments, use the normal wallet path
+                    logger.info("Using filesystem wallet")
+                    self.wallet = bittensor.wallet(
+                        name=os.getenv("WALLET_NAME", "default"),
+                        hotkey=os.getenv("WALLET_HOTKEY", "default")
+                    )
+                
+                # Connect to the testnet
+                # Using regular subtensor as AsyncSubtensor might be causing issues
+                self.subtensor = bittensor.subtensor(network="test")
+                
+                # Verify the connection works by getting current block
+                current_block = self.subtensor.get_current_block()
+                logger.info(f"Connected to Bittensor testnet, current block: {current_block}")
+                
+                # Set global variables for test compatibility
+                global subtensor, async_subtensor, is_initialized
+                subtensor = self.subtensor
+                async_subtensor = self.subtensor
+                is_initialized = True
+                
+                logger.info(f"Bittensor client initialized successfully")
+                self.is_initialized = True
+                self.initialization_error = None
+                return True
+                
+            except Exception as e:
+                logger.warning(f"Bittensor client initialization attempt {attempt}/3 failed: {e}")
+                import traceback
+                logger.debug(f"Traceback: {traceback.format_exc()}")
+                
+                self.initialization_error = str(e)
+                
+                if attempt < 3:
+                    # Wait before next attempt (with exponential backoff)
+                    wait_time = 2 ** (attempt - 1)  # 1, 2, 4 seconds
+                    logger.info(f"Waiting {wait_time} seconds before retry...")
+                    await asyncio.sleep(wait_time)
+        
+        logger.error(f"Bittensor client failed to initialize after 3 attempts")
+        return False
     
-    async def ensure_initialized(self) -> None:
+    async def ensure_initialized(self) -> bool:
         """
         Ensure the client is initialized before making any calls.
         
-        Raises:
-            RuntimeError: If the client couldn't be initialized
+        Returns:
+            bool: True if client is initialized, False otherwise
         """
         # Skip if in test environment
         if "PYTEST_CURRENT_TEST" in os.environ:
             return True
             
-        retry_count = 0
-        max_retries = 3
-        retry_delay = 1  # seconds
-        
-        while not self.is_initialized and retry_count < max_retries:
-            logger.info(f"Waiting for Bittensor client initialization (attempt {retry_count+1}/{max_retries})...")
-            await asyncio.sleep(retry_delay)
-            retry_count += 1
-        
+        # If not initialized, try to initialize again
         if not self.is_initialized:
-            logger.error("Bittensor client failed to initialize")
-            raise RuntimeError("Bittensor client is not initialized")
+            return await self.initialize()
+            
+        return self.is_initialized
     
     async def get_tao_dividends(self, netuid: Optional[int] = None, hotkey: Optional[str] = None) -> float:
         """
@@ -169,9 +181,6 @@ class BitensorClient:
             
         Returns:
             Float value representing the dividend amount
-            
-        Raises:
-            RuntimeError: If the client is not initialized or the query fails
         """
         # Check cache first (for backward compatibility)
         try:
@@ -200,8 +209,11 @@ class BitensorClient:
                 
             return dividend_value
         
-        # Otherwise, query the blockchain
-        await self.ensure_initialized()
+        # Try to ensure initialization
+        is_init = await self.ensure_initialized()
+        if not is_init:
+            logger.warning("Using simulation because client is not initialized")
+            return await simulate_dividend_query(netuid, hotkey)
         
         # Use defaults if not provided
         netuid = netuid if netuid is not None else self.default_netuid
@@ -210,8 +222,20 @@ class BitensorClient:
         try:
             logger.info(f"Querying Tao dividends for netuid={netuid}, hotkey={hotkey}")
             
-            # Query the blockchain for dividends
-            result = await self.subtensor.get_tao_dividends(netuid=netuid, hotkey=hotkey)
+            # Query the blockchain for dividends - with regular subtensor methods
+            # Adjust this based on what method is actually available in your version
+            try:
+                result = self.subtensor.get_tao_dividends_for_subnet(netuid=netuid)
+                logger.info(f"Got dividends using get_tao_dividends_for_subnet")
+            except Exception as e:
+                logger.warning(f"get_tao_dividends_for_subnet failed: {e}, trying neurons query")
+                # Fallback to checking neurons
+                neurons = self.subtensor.neurons(netuid=netuid)
+                result = 0.0  # Default if we can't find the specific hotkey
+                for neuron in neurons:
+                    if neuron.hotkey == hotkey:
+                        result = neuron.dividends if hasattr(neuron, 'dividends') else 0.0
+                        break
             
             # Process and return the result
             dividend_value = float(result) if result is not None else 0.0
@@ -227,21 +251,11 @@ class BitensorClient:
             logger.info(f"Dividend query result: {dividend_value}")
             return dividend_value
             
-        except bittensor.errors.ChainQueryError as e:
-            logger.error(f"Chain query error: {str(e)}")
-            # Fallback to simulation
-            logger.info("Using simulation as fallback")
-            dividend_value = await simulate_dividend_query(netuid, hotkey)
-            return dividend_value
-        except bittensor.errors.ChainConnectionError as e:
-            logger.error(f"Chain connection error: {str(e)}")
-            # Fallback to simulation
+        except Exception as e:
+            logger.error(f"Error in get_tao_dividends: {str(e)}")
             logger.info("Using simulation as fallback")
             dividend_value = await simulate_dividend_query(netuid, hotkey)
             return dividend_value
-        except Exception as e:
-            logger.error(f"Unexpected error in get_tao_dividends: {str(e)}")
-            raise RuntimeError(f"Failed to get dividends: {str(e)}")
     
     async def add_stake(self, amount: float, netuid: Optional[int] = None, hotkey: Optional[str] = None) -> dict:
         """
@@ -254,13 +268,16 @@ class BitensorClient:
             
         Returns:
             Dictionary with operation status and transaction hash
-            
-        Raises:
-            RuntimeError: If the staking operation fails
         """
         # Skip initialization check in test environment
         if "PYTEST_CURRENT_TEST" not in os.environ:
-            await self.ensure_initialized()
+            is_init = await self.ensure_initialized()
+            if not is_init:
+                return {
+                    "status": "failed", 
+                    "reason": "Bittensor client is not initialized", 
+                    "operation": "stake"
+                }
         
         # Use defaults if not provided
         netuid = netuid if netuid is not None else self.default_netuid
@@ -290,8 +307,8 @@ class BitensorClient:
             # Convert amount to proper units for the blockchain
             amount_rao = int(amount * 1_000_000_000)  # Convert TAO to RAO (blockchain units)
             
-            # Submit the stake extrinsic
-            tx_hash = await self.subtensor.add_stake(hotkey=hotkey, amount=amount_rao)
+            # Submit the stake extrinsic using regular subtensor methods
+            tx_hash = self.subtensor.add_stake(hotkey=hotkey, amount=amount_rao)
             
             logger.info(f"Stake added successfully: {tx_hash}")
             return {
@@ -300,12 +317,13 @@ class BitensorClient:
                 "operation": "stake"
             }
             
-        except bittensor.errors.StakeError as e:
-            logger.error(f"Staking error: {str(e)}")
-            raise RuntimeError(f"Failed to add stake: {str(e)}")
         except Exception as e:
-            logger.error(f"Unexpected error in add_stake: {str(e)}")
-            raise RuntimeError(f"Failed to add stake: {str(e)}")
+            logger.error(f"Error in add_stake: {str(e)}")
+            return {
+                "status": "failed", 
+                "reason": str(e), 
+                "operation": "stake"
+            }
     
     async def unstake(self, amount: float, netuid: Optional[int] = None, hotkey: Optional[str] = None) -> dict:
         """
@@ -318,13 +336,16 @@ class BitensorClient:
             
         Returns:
             Dictionary with operation status and transaction hash
-            
-        Raises:
-            RuntimeError: If the unstaking operation fails
         """
         # Skip initialization check in test environment
         if "PYTEST_CURRENT_TEST" not in os.environ:
-            await self.ensure_initialized()
+            is_init = await self.ensure_initialized()
+            if not is_init:
+                return {
+                    "status": "failed", 
+                    "reason": "Bittensor client is not initialized", 
+                    "operation": "unstake"
+                }
         
         # Use defaults if not provided
         netuid = netuid if netuid is not None else self.default_netuid
@@ -354,8 +375,8 @@ class BitensorClient:
             # Convert amount to proper units for the blockchain
             amount_rao = int(amount * 1_000_000_000)  # Convert TAO to RAO (blockchain units)
             
-            # Submit the unstake extrinsic
-            tx_hash = await self.subtensor.unstake(hotkey=hotkey, amount=amount_rao)
+            # Submit the unstake extrinsic using regular subtensor methods
+            tx_hash = self.subtensor.unstake(hotkey=hotkey, amount=amount_rao)
             
             logger.info(f"Stake removed successfully: {tx_hash}")
             return {
@@ -364,12 +385,13 @@ class BitensorClient:
                 "operation": "unstake"
             }
             
-        except bittensor.errors.UnstakeError as e:
-            logger.error(f"Unstaking error: {str(e)}")
-            raise RuntimeError(f"Failed to remove stake: {str(e)}")
         except Exception as e:
-            logger.error(f"Unexpected error in unstake: {str(e)}")
-            raise RuntimeError(f"Failed to remove stake: {str(e)}")
+            logger.error(f"Error in unstake: {str(e)}")
+            return {
+                "status": "failed", 
+                "reason": str(e), 
+                "operation": "unstake"
+            }
 
 # Initialize the global client instance
 def get_client():
diff --git a/docker-compose.yml b/docker-compose.yml
index ce5e0e7..f8da451 100644
--- a/docker-compose.yml
+++ b/docker-compose.yml
@@ -10,12 +10,16 @@ services:
     environment:
       - IS_DOCKER=true
       - REDIS_HOST=redis
-      - DATABASE_URL=postgresql+asyncpg://postgres:postgres@db:5432/bittensor
-      - API_TOKEN=datura
-      - DATURA_APIKEY=dt$q4qWC2K5mwT5BnNh0ZNF9MfeMDJenJ-pddsi_rE1FZ8
-      - CHUTES_API_KEY=cpk_9402c24cc755440b94f4b0931ebaa272.7a748b60e4a557f6957af9ce25778f49.8huXjHVlrSttzKuuY0yU2Fy4qEskr5J0
-      - WALLET_MNEMONIC=diamond like interest affair safe clarify lawsuit innocent beef van grief color
-      - WALLET_HOTKEY=default_hotkey_name
+      - DATABASE_URL=${DATABASE_URL}
+      - API_TOKEN=${API_TOKEN}
+      - JWT_SECRET=${JWT_SECRET}
+      - JWT_ALGORITHM=${JWT_ALGORITHM}
+      - JWT_EXPIRATION_MINUTES=${JWT_EXPIRATION_MINUTES}
+      - DATURA_API_KEY=${DATURA_API_KEY}
+      - CHUTES_API_KEY=${CHUTES_API_KEY}
+      - WALLET_MNEMONIC=${WALLET_MNEMONIC}
+      - WALLET_HOTKEY=${HOTKEY}
+      - NETUID=${NETUID}
     volumes:
       - ./data:/app/data
     depends_on:
@@ -27,16 +31,21 @@ services:
     build:
       context: .
       dockerfile: Dockerfile
+    # Update to use the root-level celery_worker.py file
     command: celery -A celery_worker worker --loglevel=info
     environment:
       - IS_DOCKER=true
       - REDIS_HOST=redis
-      - DATABASE_URL=postgresql+asyncpg://postgres:postgres@db:5432/bittensor
-      - API_TOKEN=datura
-      - DATURA_APIKEY=dt$q4qWC2K5mwT5BnNh0ZNF9MfeMDJenJ-pddsi_rE1FZ8
-      - CHUTES_API_KEY=cpk_9402c24cc755440b94f4b0931ebaa272.7a748b60e4a557f6957af9ce25778f49.8huXjHVlrSttzKuuY0yU2Fy4qEskr5J0
-      - WALLET_MNEMONIC=diamond like interest affair safe clarify lawsuit innocent beef van grief color
-      - WALLET_HOTKEY=default_hotkey_name
+      - DATABASE_URL=${DATABASE_URL}
+      - API_TOKEN=${API_TOKEN}
+      - JWT_SECRET=${JWT_SECRET}
+      - JWT_ALGORITHM=${JWT_ALGORITHM}
+      - JWT_EXPIRATION_MINUTES=${JWT_EXPIRATION_MINUTES}
+      - DATURA_API_KEY=${DATURA_API_KEY}
+      - CHUTES_API_KEY=${CHUTES_API_KEY}
+      - WALLET_MNEMONIC=${WALLET_MNEMONIC}
+      - WALLET_HOTKEY=${HOTKEY}
+      - NETUID=${NETUID}
     volumes:
       - ./data:/app/data
     depends_on:
@@ -56,9 +65,9 @@ services:
     image: postgres:15
     restart: always
     environment:
-      POSTGRES_USER: postgres
-      POSTGRES_PASSWORD: postgres
-      POSTGRES_DB: bittensor
+      POSTGRES_USER: ${POSTGRES_USER:-postgres}
+      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD:-postgres}
+      POSTGRES_DB: ${POSTGRES_DB:-bittensor}
     ports:
       - "5433:5432"
     volumes:
diff --git a/tests/__pycache__/test_auth_integration.cpython-313-pytest-8.3.5.pyc b/tests/__pycache__/test_auth_integration.cpython-313-pytest-8.3.5.pyc
index f1e19f9..1ed4531 100644
Binary files a/tests/__pycache__/test_auth_integration.cpython-313-pytest-8.3.5.pyc and b/tests/__pycache__/test_auth_integration.cpython-313-pytest-8.3.5.pyc differ
diff --git a/tests/test_auth_integration.py b/tests/test_auth_integration.py
index 7c0cbe2..53f082b 100644
--- a/tests/test_auth_integration.py
+++ b/tests/test_auth_integration.py
@@ -60,4 +60,4 @@ class TestAuthIntegration:
         assert "access_token" in data
         assert "token_type" in data
         
-        # In the future, we'll test using the JWT token here
\ No newline at end of file
+        # In the future, we'll test using the JWT token heregit log
\ No newline at end of file
